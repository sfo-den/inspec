# encoding: utf-8
# author: Dominik Richter
# author: Christoph Hartmann
# author: John Kerry

require 'rspec/core'
require 'rspec/core/formatters/json_formatter'
require 'rspec_junit_formatter'

# Vanilla RSpec JSON formatter with a slight extension to show example IDs.
# TODO: Remove these lines when RSpec includes the ID natively
class InspecRspecVanilla < RSpec::Core::Formatters::JsonFormatter
  RSpec::Core::Formatters.register self

  private

  # We are cheating and overriding a private method in RSpec's core JsonFormatter.
  # This is to avoid having to repeat this id functionality in both dump_summary
  # and dump_profile (both of which call format_example).
  # See https://github.com/rspec/rspec-core/blob/master/lib/rspec/core/formatters/json_formatter.rb
  #
  # rspec's example id here corresponds to an inspec test's control name -
  # either explicitly specified or auto-generated by rspec itself.
  def format_example(example)
    res = super(example)
    res[:id] = example.metadata[:id]
    res
  end
end

# Minimal JSON formatter for inspec. Only contains limited information about
# examples without any extras.
class InspecRspecMiniJson < RSpec::Core::Formatters::JsonFormatter
  # Don't re-register all the call-backs over and over - we automatically
  # inherit all callbacks registered by the parent class.
  RSpec::Core::Formatters.register self, :dump_summary, :stop

  # Called after stop has been called and the run is complete.
  def dump_summary(summary)
    @output_hash[:version] = Inspec::VERSION
    @output_hash[:statistics] = {
      duration: summary.duration,
    }
  end

  # Called at the end of a complete RSpec run.
  def stop(notification)
    # This might be a bit confusing. The results are not actually organized
    # by control. It is organized by test. So if a control has 3 tests, the
    # output will have 3 control entries, each one with the same control id
    # and different test results. An rspec example maps to an inspec test.
    @output_hash[:controls] = notification.examples.map do |example|
      format_example(example).tap do |hash|
        e = example.exception
        next unless e
        hash[:message] = e.message

        next if e.is_a? RSpec::Expectations::ExpectationNotMetError
        hash[:exception] = e.class.name
        hash[:backtrace] = e.backtrace
      end
    end
  end

  private

  def format_example(example)
    if example.metadata[:description_args].length > 0 && !example.metadata[:skip].nil?
      # For skipped profiles, rspec returns in full_description the skip_message as well. We don't want
      # to mix the two, so we pick the full_description from the example.metadata[:example_group] hash.
      code_description = example.metadata[:example_group][:description]
    else
      code_description = example.metadata[:full_description]
    end

    res = {
      id: example.metadata[:id],
      status: example.execution_result.status.to_s,
      code_desc: code_description,
    }

    unless (pid = example.metadata[:profile_id]).nil?
      res[:profile_id] = pid
    end

    if res[:status] == 'pending'
      res[:status] = 'skipped'
      res[:skip_message] = example.metadata[:description]
      res[:resource] = example.metadata[:described_class].to_s
    end

    res
  end
end

class InspecRspecJson < InspecRspecMiniJson # rubocop:disable Metrics/ClassLength
  RSpec::Core::Formatters.register self, :stop, :dump_summary
  attr_writer :backend

  def initialize(*args)
    super(*args)
    @profiles = []
    # Will be valid after "start" state is reached.
    @profiles_info = nil
    @backend = nil
  end

  attr_reader :profiles

  # Called by the runner during example collection.
  def add_profile(profile)
    profiles.push(profile)
  end

  def stop(notification)
    super(notification)

    @output_hash[:other_checks] = examples_without_controls
    @output_hash[:profiles] = profiles_info

    examples_with_controls.each do |example|
      control = example2control(example)
      move_example_into_control(example, control)
    end
  end

  def controls_summary
    failed = 0
    skipped = 0
    passed = 0
    critical = 0
    major = 0
    minor = 0

    @control_tests.each do |control|
      next if control[:id].start_with? '(generated from '
      next unless control[:results]
      if control[:results].any? { |r| r[:status] == 'failed' }
        failed += 1
        if control[:impact] >= 0.7
          critical += 1
        elsif control[:impact] >= 0.4
          major += 1
        else
          minor += 1
        end
      elsif control[:results].any? { |r| r[:status] == 'skipped' }
        skipped += 1
      else
        passed += 1
      end
    end

    total = failed + passed + skipped

    { 'total' => total,
      'failed' => {
        'total' => failed,
        'critical' => critical,
        'major' => major,
        'minor' => minor,
      },
      'skipped' => skipped,
      'passed' => passed }
  end

  def tests_summary
    total = 0
    failed = 0
    skipped = 0
    passed = 0

    all_tests = @anonymous_tests + @control_tests
    all_tests.each do |control|
      next unless control[:results]
      control[:results].each do |result|
        if result[:status] == 'failed'
          failed += 1
        elsif result[:status] == 'skipped'
          skipped += 1
        else
          passed += 1
        end
      end
    end

    { 'total' => total, 'failed' => failed, 'skipped' => skipped, 'passed' => passed }
  end

  private

  def examples
    @examples ||= @output_hash.delete(:controls)
  end

  def examples_without_controls
    examples.find_all { |example| example2control(example).nil? }
  end

  def examples_with_controls
    (examples - examples_without_controls)
  end

  def profiles_info
    @profiles_info ||= profiles.map(&:info!).map(&:dup)
  end

  def example2control(example)
    profile = profile_from_example(example)
    return nil unless profile && profile[:controls]
    profile[:controls].find { |x| x[:id] == example[:id] }
  end

  def profile_from_example(example)
    profiles_info.find { |p| profile_contains_example?(p, example) }
  end

  def profile_contains_example?(profile, example)
    # Heuristic for finding the profile an example came from:
    # Case 1: The profile_id on the example matches the name of the profile
    # Case 2: The profile contains a control that matches the id of the example
    if profile[:name] == example[:profile_id]
      true
    elsif profile[:controls] && profile[:controls].any? { |x| x[:id] == example[:id] }
      true
    else
      false
    end
  end

  def move_example_into_control(example, control)
    control[:results] ||= []
    example.delete(:id)
    example.delete(:profile_id)
    control[:results].push(example)
  end

  def format_example(example)
    super(example).tap do |res|
      res[:run_time]   = example.execution_result.run_time
      res[:start_time] = example.execution_result.started_at.to_s
    end
  end
end

class InspecRspecCli < InspecRspecJson # rubocop:disable Metrics/ClassLength
  RSpec::Core::Formatters.register self, :close

  COLORS = {
    'critical' => "\033[38;5;9m",
    'major'    => "\033[38;5;208m",
    'minor'    => "\033[0;36m",
    'failed'   => "\033[38;5;9m",
    'passed'   => "\033[38;5;41m",
    'skipped'  => "\033[38;5;247m",
    'reset'    => "\033[0m",
  }.freeze

  INDICATORS = {
    'critical' => '  ×  ',
    'major'    => '  ∅  ',
    'minor'    => '  ⊚  ',
    'failed'   => '  ×  ',
    'skipped'  => '  ↺  ',
    'passed'   => '  ✔  ',
    'unknown'  => '  ?  ',
    'empty'    => '     ',
    'small'    => '   ',
  }.freeze

  MULTI_TEST_CONTROL_SUMMARY_MAX_LEN = 60

  def initialize(*args)
    @current_control = nil
    @anonymous_tests = []
    @control_tests = []
    @profile_printed = false
    super(*args)
  end

  def close(_notification) # rubocop:disable Metrics/AbcSize
    flush_current_control(@current_control)
    output.puts('') if @current_control
    print_tests(@anonymous_tests)
    output.puts('')

    print_profiles_info(@current_control) if !@profile_printed
    controls_res = controls_summary
    tests_res = tests_summary

    s = format('Profile Summary: %s%d successful%s, %s%d failures%s, %s%d skipped%s',
               COLORS['passed'], controls_res['passed'], COLORS['reset'],
               COLORS['failed'], controls_res['failed']['total'], COLORS['reset'],
               COLORS['skipped'], controls_res['skipped'], COLORS['reset'])
    output.puts(s) if controls_res['total'] > 0

    s = format('Test Summary: %s%d successful%s, %s%d failures%s, %s%d skipped%s',
               COLORS['passed'], tests_res['passed'], COLORS['reset'],
               COLORS['failed'], tests_res['failed'], COLORS['reset'],
               COLORS['skipped'], tests_res['skipped'], COLORS['reset'])
    output.puts(s) if !@anonymous_tests.empty? || @current_control.nil?
  end

  private

  # Formats example; calls example2control, gets a 'status_type', and calls
  # flush current_control; returns control data
  def format_example(example)
    data = super(example)
    control = example2control(data, @profiles_info) || {}
    control[:id] = data[:id]
    control[:profile_id] = data[:profile_id]

    data[:status_type] = status_type(data, control)
    dump_one_example(data, control)

    @current_control ||= control
    if !control[:id].nil?
      if @current_control[:id] != control[:id]
        flush_current_control(@current_control)
        @current_control = control
      end
    end

    data
  end

  # Determines 'status_type' (critical, major, minor) of control given
  # status (failed/passed/skipped) and impact value (0.0 - 1.0).
  # Called from format_example, sets the 'status_type' for each 'example'
  def status_type(data, control)
    status = data[:status]
    return status if status != 'failed' || control[:impact].nil?
    if control[:impact] >= 0.7
      'critical'
    elsif control[:impact] >= 0.4
      'major'
    else
      'minor'
    end
  end

  # Formats the line (called from print_line)
  def format_line(fields)
    format = '%color%indicator%id%summary'
    format.gsub(/%\w+/) do |x|
      term = x[1..-1]
      fields.key?(term.to_sym) ? fields[term.to_sym].to_s : x
    end + COLORS['reset']
  end

  # Prints line; used to print results
  def print_line(fields)
    output.puts(format_line(fields))
  end

  # Helps formatting summary lines (called from within print_line arguments)
  def format_lines(lines, indentation)
    lines.gsub(/\n/, "\n" + indentation)
  end

  # Sorts through results, calls print_line (called from flush_current_control)
  def print_results(all)
    all.each do |x|
      test_status = x[:status_type]
      test_color = COLORS[test_status]
      indicator = INDICATORS[x[:status]]
      indicator = INDICATORS['empty'] if indicator.nil?
      if x[:message]
        msg = x[:code_desc] + "\n" + x[:message]
      else
        msg = x[:skip_message] || x[:code_desc]
      end
      print_line(
        color:      test_color,
        indicator:  INDICATORS['small'] + indicator,
        summary:    format_lines(msg, INDICATORS['empty']),
        id: nil, profile: nil
      )
    end
  end

  # Prints anonymous describe blocks; called from close function
  def print_tests(anonymous_tests) # rubocop:disable Metrics/AbcSize
    anonymous_tests.each do |control|
      control_result = control[:results]
      title = control_result[0][:code_desc].split[0..1].join(' ')
      puts '  ' + title
      # iterate over all describe blocks in anonoymous control block
      control_result.each do |test|
        control_id = ''
        # display exceptions
        unless test[:exception].nil?
          test_result = test[:message]
        else
          # determine title
          test_result = test[:skip_message] || test[:code_desc].split[2..-1].join(' ')
          # show error message
          test_result += "\n" + test[:message] unless test[:message].nil?
        end
        status_indicator = test[:status_type]
        print_line(
          color:      COLORS[status_indicator] || '',
          indicator:  INDICATORS['small'] + INDICATORS[status_indicator] || INDICATORS['unknown'],
          summary:    format_lines(test_result, INDICATORS['empty']),
          id:         control_id,
          profile:    control[:profile_id],
        )
      end
    end
  end


  # TODO: does a lot of stuff!
  # Called from format_example and close
  def flush_current_control(control)
    return if control.nil?
    profile = control2profile(control)

    cc = CurrentControl.new(control,profile)

    print_current_profile(cc.profile) if !@profile_printed

    if cc.anonymous?
      @anonymous_tests.push(control)
    else
      @control_tests.push(control)
      print_line(
        color:      COLORS[cc.summary_indicator] || '',
        indicator:  INDICATORS[cc.summary_indicator] || INDICATORS['unknown'],
        summary:    format_lines(cc.summary, INDICATORS['empty']),
        id:         "#{cc.id}: ",
        profile:    cc.profile_id,
      )

      print_results(cc.fails + cc.skips + cc.passes)
    end
  end

  def control2profile(control)
    profiles_info.find { |i| i[:id] == control[:profile_id] }
  end

  def print_current_profile(profile)
    if profile.nil?
      print_profiles_info(@current_control)
      @profile_printed = true
      return true
    end
    output.puts ''
    profile[:already_printed] = true

    if profile[:name].nil?
      print_target
      @profile_printed = true
      return true
    end

    if profile[:title].nil?
      output.puts "Profile: #{profile[:name] || 'unknown'}"
    else
      output.puts "Profile: #{profile[:title]} (#{profile[:name] || 'unknown'})"
    end

    output.puts 'Version: ' + (profile[:version] || 'unknown')
    print_target
    @profile_printed = true
    true
  end
end

class InspecRspecJUnit < RSpecJUnitFormatter
  RSpec::Core::Formatters.register self, :close

  # Prints target information; called from print_current_profile
  def print_target
    return if @backend.nil?
    connection = @backend.backend
    return unless connection.respond_to?(:uri)
    output.puts('Target:  ' + connection.uri + "\n\n")
  end

  # Prints blank info is no current_control is defined
  # Called from print_current_profile and close
  def print_profiles_info(current_control)
    profiles_info.each do |profile|
      next if profile[:already_printed]
      next unless print_current_profile(profile)
      print_line(
        color: '', indicator: INDICATORS['empty'], id: '', profile: '',
        summary: 'No tests executed.'
      ) if @current_control.nil?
      output.puts('')
    end
  end

  def format_example(example)
    data = super(example)
    control = example2control(data) || {}
    control[:id] = data[:id]
    control[:profile_id] = data[:profile_id]

    data[:status_type] = status_type(data, control)
    move_example_into_control(data, control)

  def initialize(*args)
    super(*args)
  end

  def close(_notification)
  end

  #
  # This class wraps a control object to provide a useful inteface for
  # maintaining the associated profile, ids, results, title, etc.
  #
  class CurrentControl

    STATUS_TYPES = {
      'unknown'  => -3,
      'passed'   => -2,
      'skipped'  => -1,
      'minor'    => 1,
      'major'    => 2,
      'failed'   => 2.5,
      'critical' => 3,
    }.freeze

    def initialize(control,profile)
      @control = control
      @profile
      calculate_results
    end

    attr_reader :control, :profile

    attr_reader :skips, :fails, :passes, :summary_indicator

    def id
      control[:id]
    end

    def anonymous?
      control[:id].to_s.start_with? '(generated from '
    end

    def profile_id
      control[:profile_id]
    end

    def calculate_results
      summary_status = STATUS_TYPES['unknown']
      @skips = []
      @fails = []
      @passes = []
      control[:results].each do |r|
        i = STATUS_TYPES[r[:status_type]]
        summary_status = i if i > summary_status
        fails.push(r) if i > 0
        passes.push(r) if i == STATUS_TYPES['passed']
        skips.push(r) if i == STATUS_TYPES['skipped']
      end
      @summary_indicator = STATUS_TYPES.key(summary_status)
    end

    # Determine title for control given current_control.
    # Called from current_control_summary.
    def title
      title = control[:title]
      res = control[:results]
      if title
        title
      elsif res.length == 1
        # If it's an anonymous control, just go with the only description
        # available for the underlying test.
        res[0][:code_desc].to_s
      elsif res.length == 0
        # Empty control block - if it's anonymous, there's nothing we can do.
        # Is this case even possible?
        'Empty anonymous control'
      else
        # Multiple tests - but no title. Do our best and generate some form of
        # identifier or label or name.
        title = (res.map { |r| r[:code_desc] }).join('; ')
        max_len = MULTI_TEST_CONTROL_SUMMARY_MAX_LEN
        title = title[0..(max_len-1)] + '...' if title.length > max_len
        title
      end
    end

    # Return summary of the control which is usually a title with fails and skips
    def summary
      res = control[:results]
      suffix =
        if res.length == 1
          # Single test - be nice and just print the exception message if the test
          # failed. No need to say "1 failed".
          res[0][:message].to_s
        else
          [
            (fails.length > 0) ? "#{fails.length} failed" : nil,
            (skips.length > 0) ? "#{skips.length} skipped" : nil,
          ].compact.join(' ')
        end
      if suffix == ''
        title
      else
        title + ' (' + suffix + ')'
      end
    end
  end
end
