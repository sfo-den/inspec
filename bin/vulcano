#!/usr/bin/env ruby
# encoding: utf-8
# Copyright 2015 Dominik Richter. All rights reserved.
# author: Dominik Richter
# author: Christoph Hartmann

require 'thor'
require 'json'
require_relative '../lib/vulcano'

class VulcanoCLI < Thor
  desc 'json PATH', 'read all tests in PATH and generate a JSON-profile'
  option :output, aliases: :o, type: :string
  option :print, aliases: :p, type: :boolean
  option :id, type: :string
  def json(*paths)
    require_relative '../lib/verify'
    paths.each do |path|
      Vulcano::Profiles.new.valid_folder? path unless options[:print]
      vc = Vulcano::Profiles.new({ quiet: options[:print], id: options[:id] })
      vc.add_folder(path)
      if options[:print]
        puts JSON.pretty_generate(vc.profiles)
      else
        dst = options[:output] || File.join(path, '.vulcano.json')
        if File.exist? dst
          puts "----> updating #{dst}"
        else
          puts "----> creating #{dst}"
        end
        fdst = File.expand_path(dst)
        File.write(fdst, JSON.dump(vc.profiles))
      end
    end
  end

  desc 'check PATH', 'check all tests in PATH'
  def check(*paths)
    require_relative '../lib/verify'
    paths.each do |path|
      puts "#{path}"
      Vulcano::Profiles.new.valid_folder? path
      puts
    end
  end

  def self.target_options
    option :target, aliases: :t, type: :string, default: nil,
      desc: 'Simple targeting option using URIs, e.g. ssh://user:pass@host:port'
    option :backend, aliases: :b, type: :string, default: nil,
      desc: 'Choose a backend: local, ssh, winrm, docker.'
    option :host, type: :string,
      desc: 'Specify a remote host which is tested.'
    option :port, type: :numeric,
      desc: 'Specify the login port for a remote scan.'
    option :user, type: :string, default: nil,
      desc: 'The login user for a remote scan.'
    option :password, type: :string, default: nil,
      desc: 'Login password for a remote scan, if required.'
    option :key, type: :string, default: nil,
      desc: 'Login key or certificate file for a remote scan.'
    option :path, type: :string, default: nil,
      desc: 'Login path to use in connectin to the target.'
    option :disable_sudo, type: :boolean, default: false,
      desc: 'To not run remote scans via sudo.'
    option :sudo_password, type: :string, default: nil,
      desc: 'Specify a sudo password, if it is required.'
    option :sudo_options, type: :string, default: '',
      desc: 'Additional sudo options for a remote scan.'
    option :ssl, type: :boolean, default: false,
      desc: 'Use SSL for transport layer encryptiong (WinRM).'
    option :self_signed, type: :boolean, default: false,
      desc: 'Allow remote scans with self-signed certificates (WinRM).'
  end

  desc 'exec PATHS', 'run all test files'
  option :id, type: :string,
    desc: 'Attach a profile ID to all test results'
  target_options
  option :format, type: :string, default: 'progress'
  def exec(*tests)
    runner = Vulcano::Runner.new(options)
    runner.add_tests(tests)
    runner.run
  rescue RuntimeError => e
    puts e.message
  end

  desc 'detect', 'detect the target OS'
  target_options
  def detect
    runner = Vulcano::Runner.new(options)
    detect_util = File.expand_path(rel)
    runner.add_tests([detect_util])
    runner.run
  rescue RuntimeError => e
    puts e.message
  end

  desc 'shell', 'open an interactive debugging shell'
  target_options
  def shell_func
    runner = Vulcano::Runner.new(options)
    Vulcano::Shell.new(runner).start
  rescue RuntimeError => e
    puts e.message
  end

  desc 'version', 'prints the version of this tool'
  def version
    puts Vulcano::VERSION
  end
end
VulcanoCLI.start(ARGV)
